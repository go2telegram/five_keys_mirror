name: codex_dispatch

on:
  repository_dispatch:
    types: [codex_command]

env:
  PYTHONPATH: .

permissions:
  contents: write
  pull-requests: write

jobs:
  dispatch:
    runs-on: ubuntu-latest
    steps:
      - name: Parse command
        id: p
        uses: actions/github-script@v7
        env:
          CODEX_SHARED_KEY: ${{ secrets.CODEX_SHARED_KEY }}
        with:
          script: |
            const payload = context.payload.client_payload || {};
            const expectedKey = process.env.CODEX_SHARED_KEY;
            if (!expectedKey) {
              core.setFailed('Secret CODEX_SHARED_KEY is not configured');
              return;
            }
            if (!payload.key) {
              core.setFailed('client_payload.key is required');
              return;
            }
            if (payload.key !== expectedKey) {
              core.setFailed('Invalid client payload key');
              return;
            }
            const cmd = payload.cmd || '';
            const allowed = ['render_menu', 'build_catalog', 'open_patch_pr', 'lint_autofix', 'doctor'];
            if (!cmd || !allowed.includes(cmd)) {
              core.setFailed(`Unsupported cmd: ${cmd}`);
              return;
            }
            core.setOutput('cmd', cmd);
            core.setOutput('msg', payload.msg || '');
            core.setOutput('patch_b64', payload.patch_b64 || '');

      - name: Checkout
        if: steps.p.outputs.cmd != ''
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        if: contains('build_catalog open_patch_pr lint_autofix', steps.p.outputs.cmd)
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Setup Node
        if: steps.p.outputs.cmd == 'render_menu'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Mermaid CLI
        if: steps.p.outputs.cmd == 'render_menu'
        run: npm i -g @mermaid-js/mermaid-cli@10

      - name: Render menu diagrams
        if: steps.p.outputs.cmd == 'render_menu'
        run: |
          npx @mermaid-js/mermaid-cli \
            -i docs/menu_map.mmd \
            -o docs/menu_map.svg \
            -b transparent -w 1400

      - name: Install dependencies (build_catalog)
        if: steps.p.outputs.cmd == 'build_catalog'
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Build catalog
        if: steps.p.outputs.cmd == 'build_catalog'
        run: |
          python tools/build_products.py build
          python tools/build_products.py validate

      - name: Apply patch
        if: steps.p.outputs.cmd == 'open_patch_pr'
        run: |
          if [ -z "${{ steps.p.outputs.patch_b64 }}" ]; then
            echo "patch_b64 is required for open_patch_pr" >&2
            exit 1
          fi
          echo "${{ steps.p.outputs.patch_b64 }}" | base64 -d > /tmp/codex.patch
          git apply --whitespace=nowarn /tmp/codex.patch
          git add -A

      - name: Lint autofix
        if: steps.p.outputs.cmd == 'lint_autofix'
        run: bash scripts/lint_autofix.sh

      # ----- doctor: health-пинг (check-only / fix-safe) -----
      - name: Doctor report (gather)
        if: steps.p.outputs.cmd == 'doctor'
        id: doctor
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const fix   = !!${{ toJSON(github.event.client_payload.fix || false) }};

            const ok = (b)=> b ? "✅" : "❌";
            const safe = async (fn, def=null)=> { try { return await fn(); } catch(e){ core.info('WARN: '+e.message); return def; } };

            // repo info
            const repoInfo = await github.rest.repos.get({owner, repo});
            const allowAutoMerge = repoInfo.data.allow_auto_merge;
            const isPrivate      = repoInfo.data.private;

            // actions permissions
            const actsPerm = await safe(()=> github.request('GET /repos/{owner}/{repo}/actions/permissions',{owner,repo}), {data:{enabled:true, allowed_actions:'all'}});
            const wfPerm   = await safe(()=> github.request('GET /repos/{owner}/{repo}/actions/permissions/workflow',{owner,repo}), {data:{default_workflow_permissions:'write', can_approve_pull_request_reviews:true}});

            // secrets
            const secrets = await safe(()=> github.rest.actions.listRepoSecrets({owner,repo, per_page:100}), {data:{secrets:[]}});
            const hasShared = secrets.data.secrets.some(s=> s.name==='CODEX_SHARED_KEY');

            // labels
            const labels = await safe(()=> github.rest.issues.listLabelsForRepo({owner,repo, per_page:100}), {data:[]});
            const needLabels = ['automerge','codex','risky','needs-human'];
            const haveLabels = new Set(labels.data.map(l=>l.name));
            const missingLabels = needLabels.filter(l=> !haveLabels.has(l));

            // workflows
            const wfList = await safe(()=> github.rest.actions.listRepoWorkflows({owner,repo, per_page:100}), {data:{workflows:[]}});
            const haveWF = new Set(wfList.data.workflows.map(w=> w.name));
            const needWF = ['CI','nightly_load','pr_automerge','codex_dispatch','auto_label'];
            const missingWF = needWF.filter(n=> !haveWF.has(n));

            // last runs
            async function lastRun(name){
              const wf = wfList.data.workflows.find(w=> w.name===name);
              if(!wf) return {name, exists:false};
              const runs = await safe(()=> github.rest.actions.listWorkflowRuns({owner,repo, workflow_id: wf.id, per_page:1}), {data:{workflow_runs:[]}});
              const r = runs.data.workflow_runs[0];
              return {name, exists:true, status: r?.status, conclusion: r?.conclusion, html_url: r?.html_url};
            }
            const runs = [];
            for (const n of ['CI','nightly_load','pr_automerge','auto_label']) {
              runs.push(await lastRun(n));
            }

            // branch protection (может быть недоступно / 403 на private/free)
            let protection = {enabled:false, note:'not enabled or not available'};
            try {
              const p = await github.request('GET /repos/{owner}/{repo}/branches/{branch}/protection',{owner,repo,branch:'main'});
              protection = {enabled:true, strict:p.data?.required_status_checks?.strict ?? false};
            } catch(e) { core.info('branch protection: '+e.message); }

            const problems = [];
            if (!hasShared) problems.push('Нет секрета CODEX_SHARED_KEY');
            if (missingLabels.length) problems.push('Нет меток: ' + missingLabels.join(', '));
            if (missingWF.length) problems.push('Нет workflow: ' + missingWF.join(', '));
            for (const r of runs) if (r.exists && r.conclusion && r.conclusion !== 'success') problems.push(`Workflow ${r.name}: ${r.conclusion}`);

            const fs = require('fs'); const path=require('path');
            const dir = path.join(process.cwd(),'build','reports');
            fs.mkdirSync(dir,{recursive:true});
            const md = [
              `# Dev health report`,
              `*Time:* ${new Date().toISOString()}`,
              '',
              `**Repo:** ${owner}/${repo} ${isPrivate?'(private)':''}`,
              `- Auto-merge (UI): ${ok(allowAutoMerge)}  _(не обязателен — auto-merge workflow работает)_`,
              `- Actions: enabled=${actsPerm.data.enabled} allowed=${actsPerm.data.allowed_actions}`,
              `- Workflow perms: default=${wfPerm.data.default_workflow_permissions} can_approve=${wfPerm.data.can_approve_pull_request_reviews}`,
              `- Secret CODEX_SHARED_KEY: ${ok(hasShared)}`,
              `- Labels present: ${ok(missingLabels.length===0)} ${missingLabels.length?('(нет: '+missingLabels.join(', ')+')'):''}`,
              `- Workflows present: ${ok(missingWF.length===0)} ${missingWF.length?('(нет: '+missingWF.join(', ')+')'):''}`,
              `- Branch protection(main): ${protection.enabled? 'enabled' : 'disabled'}${protection.enabled?(' strict='+(protection.strict?'on':'off')):''}`,
              '',
              '## Last runs',
              ...runs.map(r=> `- **${r.name}**: ${r.exists? (r.conclusion||r.status||'n/a') : 'нет'} ${r.html_url?(' · '+r.html_url):''}`),
              '',
              problems.length? '## ⚠️ Problems' : '## ✅ OK',
              problems.map(p=> `- ${p}`).join('\n'),
              '',
              `Mode: ${fix? 'fix-safe' : 'check-only'}`
            ].join('\n');
            fs.writeFileSync(path.join(dir,'dev_check.md'), md);
            fs.writeFileSync(path.join(dir,'dev_check.json'), JSON.stringify({
              repo:{allowAutoMerge,isPrivate},
              actions:actsPerm.data,
              workflowPerms:wfPerm.data,
              hasShared, missingLabels, missingWF, runs, protection, problems
            },null,2));

            core.setOutput('fix', String(fix));
            core.setOutput('problems', String(problems.length));
            core.setOutput('missingLabels', JSON.stringify(missingLabels));
            core.setOutput('missingWF', JSON.stringify(missingWF));

      # авто-фиксы (безопасные): создаём недостающие метки
      - name: Create missing labels (safe fix)
        if: steps.doctor.outputs.fix == 'true' && steps.doctor.outputs.missingLabels != '[]'
        uses: actions/github-script@v7
        with:
          script: |
            const miss = JSON.parse(`${{ steps.doctor.outputs.missingLabels }}`);
            const colors = {automerge:'36B37E', codex:'6554C0', risky:'FFAB00', 'needs-human':'FF5630'};
            for (const name of miss) {
              try {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner, repo: context.repo.repo,
                  name, color: colors[name]||'1F1F1F', description: name
                });
                core.info('label created: '+name);
              } catch(e) { core.warning(e.message); }
            }

      # авто-фиксы через PR: если нет workflow — кладём шаблоны в ветку PR
      - name: Prepare scaffolds when workflows missing
        if: steps.doctor.outputs.fix == 'true' && steps.doctor.outputs.missingWF != '[]'
        run: |
          mkdir -p .github/workflows
          # Складываем только отсутствующие; файлы ниже – минимальные заглушки
          echo "name: auto_label\non: [workflow_run]\njobs:\n  noop:\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo 'placeholder'" > .github/workflows/auto_label.yml
          echo "name: pr_automerge\non: [pull_request]\njobs:\n  noop:\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo 'placeholder'" > .github/workflows/pr_automerge.yml

      - name: PR (doctor fixes)
        if: steps.doctor.outputs.fix == 'true' && steps.doctor.outputs.missingWF != '[]'
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "doctor: add missing workflow scaffolds"
          title: "doctor: add missing workflow scaffolds"
          body: "Placeholder workflows added. Замените заглушки на реальные конфиги."
          branch: "codex-doctor-fix-${{ github.run_id }}"
          base: "main"
          labels: "codex,needs-human"
          add-paths: |
            .github/workflows/auto_label.yml
            .github/workflows/pr_automerge.yml
            build/reports/dev_check.*
            # dev_check всегда добавляем

      # Отчёт (artifact) если фиксов не было и проблем=0
      - name: Upload doctor artifact
        if: steps.doctor.outputs.fix != 'true' && steps.doctor.outputs.problems == '0'
        uses: actions/upload-artifact@v4
        with:
          name: dev_check-${{ github.run_id }}
          path: build/reports/*

      - name: PR (render_menu)
        if: steps.p.outputs.cmd == 'render_menu'
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "codex(docs): render menu diagrams"
          title: ${{ steps.p.outputs.msg != '' && steps.p.outputs.msg || 'codex(docs): render menu diagrams' }}
          body: "Автогенерация диаграмм Mermaid. Открыто через repository_dispatch."
          branch: "codex-render-${{ github.run_id }}"
          base: "main"
          labels: "codex,automerge"
          add-paths: |
            docs/menu_map.svg

      - name: PR (build_catalog)
        if: steps.p.outputs.cmd == 'build_catalog'
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "codex(build): rebuild catalog"
          title: ${{ steps.p.outputs.msg != '' && steps.p.outputs.msg || 'codex(build): rebuild catalog' }}
          body: "Сборка каталога выполнена через repository_dispatch."
          branch: "codex-catalog-${{ github.run_id }}"
          base: "main"
          labels: "codex,automerge"
          add-paths: |
            app/catalog/**
            build/**

      - name: PR (open_patch_pr)
        if: steps.p.outputs.cmd == 'open_patch_pr'
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: ${{ steps.p.outputs.msg != '' && steps.p.outputs.msg || 'codex(patch): apply patch' }}
          title: ${{ steps.p.outputs.msg != '' && steps.p.outputs.msg || 'codex(patch): apply patch' }}
          body: "Патч применён через repository_dispatch."
          branch: "codex-patch-${{ github.run_id }}"
          base: "main"
          labels: "codex,automerge"

      - name: PR (lint_autofix)
        if: steps.p.outputs.cmd == 'lint_autofix'
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "codex(lint): autofix formatting"
          title: "codex(lint): autofix formatting"
          body: "Auto-format via black/isort from repository_dispatch."
          branch: "codex-lint-${{ github.run_id }}"
          base: "main"
          labels: "codex,automerge"
          add-paths: |
            **/*.py
            pyproject.toml
            scripts/lint_autofix.sh
